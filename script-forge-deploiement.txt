#!/bin/bash

cd /home/forge/new.dinorapp.com

# Fonction pour les logs (compatible Forge)
log_info() {
    echo "â„¹ï¸  $1"
}

log_success() {
    echo "âœ… $1"
}

log_warning() {
    echo "âš ï¸  $1"
}

log_error() {
    echo "âŒ $1"
}

echo "ğŸš€ === DÃ‰PLOIEMENT DINOR DASHBOARD DIGITAL OCEAN ==="
echo ""

# 1. Mise en mode maintenance (dÃ©placÃ©e aprÃ¨s l'installation Composer pour Ã©viter les erreurs de dÃ©pendances)

# 2. Nettoyage prÃ©alable des conflits Git
log_info "ğŸ§¹ Nettoyage des conflits Git potentiels..."

# Supprimer les fichiers de logs qui causent des conflits
rm -rf storage/logs/*.log 2>/dev/null || true
rm -rf storage/logs/laravel.log 2>/dev/null || true

# Nettoyer les fichiers temporaires qui peuvent causer des conflits
rm -rf storage/framework/cache/data/* 2>/dev/null || true
rm -rf storage/framework/sessions/* 2>/dev/null || true
rm -rf storage/framework/views/*.php 2>/dev/null || true
rm -rf bootstrap/cache/*.php 2>/dev/null || true

# Nettoyer le cache Git
git rm --cached storage/logs/*.log 2>/dev/null || true
git rm --cached storage/logs/laravel.log 2>/dev/null || true

# Corriger les permissions PWA avant git pull
log_info "ğŸ” Correction des permissions PWA..."
chown -R forge:forge public/pwa/ 2>/dev/null || true
chmod -R 755 public/pwa/ 2>/dev/null || true
rm -rf public/pwa/dist/* 2>/dev/null || true

# Corriger les permissions Git (Ã©vite "Permission denied" sur .git/logs/)
log_info "ğŸ” Correction des permissions Git..."
chown -R forge:forge .git/ 2>/dev/null || true

# Stash les changements locaux s'il y en a (sÃ©curitÃ©)
if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    log_warning "Changements locaux dÃ©tectÃ©s, sauvegarde temporaire..."
    git stash push -m "Sauvegarde automatique Forge $(date)" 2>/dev/null || true
fi

log_success "Conflits Git nettoyÃ©s"

# 3. Mise Ã  jour du code source
log_info "ğŸ“¥ Mise Ã  jour du code source..."
git fetch origin $FORGE_SITE_BRANCH
git reset --hard origin/$FORGE_SITE_BRANCH
log_success "Code source mis Ã  jour"

# 4. Nettoyage prÃ©alable des dÃ©pendances
log_info "ğŸ§¹ Nettoyage des anciennes dÃ©pendances..."
rm -rf vendor/ 2>/dev/null || true
# Ne pas supprimer composer.lock afin d'installer exactement les versions verrouillÃ©es
log_success "Anciennes dÃ©pendances supprimÃ©es"

# 5. Installation des dÃ©pendances Composer avec nunomaduro/collision
log_info "ğŸ“¦ Installation des dÃ©pendances Composer..."
$FORGE_COMPOSER install --no-dev --no-interaction --prefer-dist --optimize-autoloader
if [ $? -ne 0 ]; then
    log_error "Erreur lors de l'installation Composer"
    exit 1
fi
log_success "DÃ©pendances Composer installÃ©es"

# 5.bis Mise en mode maintenance (aprÃ¨s installation Composer pour garantir la disponibilitÃ© des traits/packages)
log_info "ğŸ”„ Mise en mode maintenance..."
$FORGE_PHP artisan down --retry=60 --render="errors::503" --secret="dinor-maintenance-secret" || log_warning "Impossible de mettre en mode maintenance"

# 5.ter VÃ©rification du plugin Filament Spatie Media Library (pour SpatieMediaLibraryFileUpload)
log_info "ğŸ” VÃ©rification du plugin Filament Spatie Media Library..."
if [ ! -d "vendor/filament/spatie-laravel-media-library-plugin" ]; then
    log_warning "Plugin manquant, installation..."
    $FORGE_COMPOSER require filament/spatie-laravel-media-library-plugin:^3.0 --no-interaction || log_error "Impossible d'installer le plugin Filament Media Library"
else
    log_success "Plugin Filament Spatie Media Library prÃ©sent"
fi

# 6. VÃ©rification que les dÃ©pendances critiques sont installÃ©es
log_info "ğŸ” VÃ©rification des dÃ©pendances critiques..."
if [ ! -d "vendor/nunomaduro/collision" ]; then
    log_warning "Tentative d'installation manuelle de nunomaduro/collision..."
    $FORGE_COMPOSER require nunomaduro/collision:^7.0 --no-interaction
fi
log_success "DÃ©pendances critiques vÃ©rifiÃ©es"

# 7. GÃ©nÃ©ration de la clÃ© d'application si nÃ©cessaire
log_info "ğŸ”‘ VÃ©rification de la clÃ© d'application..."
if ! grep -q "APP_KEY=base64:" .env 2>/dev/null; then
    log_warning "GÃ©nÃ©ration d'une nouvelle clÃ© d'application..."
    $FORGE_PHP artisan key:generate --force
    log_success "ClÃ© d'application gÃ©nÃ©rÃ©e"
else
    log_info "ClÃ© d'application dÃ©jÃ  prÃ©sente"
fi

# 8. Configuration des variables d'environnement (SANS secrets)
log_info "âš™ï¸ Configuration des variables d'environnement..."

# Fonction pour mettre Ã  jour les variables d'environnement
update_env_var() {
    local key=$1
    local value=$2

    # Ã‰chapper les valeurs avec des espaces ou des caractÃ¨res spÃ©ciaux
    if [[ "$value" == *" "* ]] || [[ "$value" == *"!"* ]]; then
        value="\"${value}\""
    fi

    if grep -q "^${key}=" .env 2>/dev/null; then
        sed -i "s/^${key}=.*/${key}=${value}/" .env
    else
        echo "${key}=${value}" >> .env
    fi
}

# Variables admin NON sensibles (le mot de passe doit Ãªtre configurÃ© manuellement dans .env sur le serveur)
update_env_var "ADMIN_DEFAULT_EMAIL" "admin@dinor.app"
update_env_var "ADMIN_DEFAULT_NAME" "AdministrateurDinor"

# VÃ©rifier que ADMIN_DEFAULT_PASSWORD est dÃ©fini dans .env
if ! grep -q "^ADMIN_DEFAULT_PASSWORD=.\+" .env 2>/dev/null; then
    log_error "ADMIN_DEFAULT_PASSWORD non dÃ©fini dans .env ! Configurez-le manuellement sur le serveur."
    log_error "Commande: echo 'ADMIN_DEFAULT_PASSWORD=\"votre_mot_de_passe\"' >> .env"
fi

# Variables de production importantes
update_env_var "APP_ENV" "production"
update_env_var "APP_DEBUG" "false"
update_env_var "SESSION_SECURE_COOKIE" "true"
update_env_var "SESSION_SAME_SITE" "lax"

# Variables de cache pour Ã©viter les erreurs
update_env_var "CACHE_DRIVER" "file"
update_env_var "SESSION_DRIVER" "file"
update_env_var "QUEUE_CONNECTION" "sync"

# Variables de logging
update_env_var "LOG_CHANNEL" "stack"
update_env_var "LOG_DEPRECATIONS_CHANNEL" "null"
update_env_var "LOG_LEVEL" "debug"

log_success "Variables d'environnement configurÃ©es"

# 9. Nettoyage des caches avant NPM
log_info "ğŸ§¹ Nettoyage des caches Laravel..."
$FORGE_PHP artisan optimize:clear || log_warning "ProblÃ¨me avec optimize:clear, mais continue..."
# Nettoyage manuel des caches en cas d'Ã©chec
rm -rf bootstrap/cache/*.php storage/framework/cache/data/* storage/framework/views/*.php 2>/dev/null || true
log_success "Caches Laravel nettoyÃ©s"

# 10. Installation complÃ¨te des dÃ©pendances NPM
log_info "ğŸ“¦ Installation des dÃ©pendances NPM..."

# Nettoyage complet et agressif des permissions NPM
log_info "ğŸ” Correction agressive des permissions NPM..."

# PremiÃ¨re tentative: permissions standards
chown -R forge:forge node_modules/ 2>/dev/null || true
chown -R forge:forge package-lock.json 2>/dev/null || true
chown -R forge:forge .npm/ 2>/dev/null || true
chmod -R 755 node_modules/ 2>/dev/null || true

# Correction spÃ©cifique pour tous les fichiers cachÃ©s problÃ©matiques
if [ -d "node_modules" ]; then
    log_info "ğŸ”§ Correction des fichiers cachÃ©s dans node_modules..."
    find node_modules/ -name ".*" -type f -exec chown forge:forge {} \; 2>/dev/null || true
    find node_modules/ -name ".*" -type f -exec chmod 644 {} \; 2>/dev/null || true
    find node_modules/ -name ".*" -type d -exec chown forge:forge {} \; 2>/dev/null || true
    find node_modules/ -name ".*" -type d -exec chmod 755 {} \; 2>/dev/null || true
fi

# Suppression forcÃ©e des fichiers problÃ©matiques spÃ©cifiques
log_info "ğŸ—‘ï¸ Suppression forcÃ©e des fichiers problÃ©matiques..."
rm -f node_modules/.package-lock.json 2>/dev/null || true
rm -f .package-lock.json 2>/dev/null || true
rm -f package-lock.json 2>/dev/null || true

# Nettoyage total avec plusieurs mÃ©thodes
rm -rf node_modules/ 2>/dev/null || true
[ -d "node_modules" ] && find node_modules/ -delete 2>/dev/null || true
rm -rf .npm/ 2>/dev/null || true

# Nettoyage du cache NPM utilisateur
rm -rf ~/.npm/_cacache 2>/dev/null || true
rm -rf /home/forge/.npm/_cacache 2>/dev/null || true

# Installation NPM avec gestion d'erreurs amÃ©liorÃ©e
log_info "ğŸš€ Tentative d'installation NPM..."
if npm install --no-fund --no-audit; then
    log_success "DÃ©pendances NPM installÃ©es avec succÃ¨s"
elif npm ci --no-fund --no-audit 2>/dev/null; then
    log_success "DÃ©pendances NPM installÃ©es avec npm ci"
elif npm install --force --no-fund --no-audit; then
    log_warning "DÃ©pendances NPM installÃ©es avec --force"
else
    log_warning "Ã‰chec NPM standard, nettoyage agressif et nouvelle tentative..."

    # Nettoyage agressif alternatif sans sudo
    log_info "ğŸ§¹ Nettoyage agressif du rÃ©pertoire NPM..."

    # Changer vers le rÃ©pertoire parent et recrÃ©er complÃ¨tement
    cd /home/forge/new.dinorapp.com

    # Suppression rÃ©cursive alternative
    [ -d "node_modules" ] && rm -rf node_modules/* 2>/dev/null || true
    [ -d "node_modules" ] && rmdir node_modules/ 2>/dev/null || true

    # Nettoyer tous les lock files
    rm -f package-lock.json npm-shrinkwrap.json yarn.lock 2>/dev/null || true

    # Vider complÃ¨tement le cache NPM
    npm cache clean --force 2>/dev/null || true

    # DerniÃ¨re tentative avec cache dÃ©sactivÃ©
    if npm install --no-fund --no-audit --no-optional --prefer-offline=false --cache=/tmp/npm-cache-temp; then
        log_success "âœ… NPM installÃ© avec cache temporaire"
        # Nettoyer le cache temporaire
        rm -rf /tmp/npm-cache-temp 2>/dev/null || true
    else
        log_error "âŒ Ã‰chec complet NPM - continue avec build Vite uniquement"
        # CrÃ©er un node_modules vide pour Ã©viter les erreurs
        mkdir -p node_modules/.bin
        touch node_modules/.package-lock.json
        chown -R forge:forge node_modules/ 2>/dev/null || true
    fi
fi

# VÃ©rifier et corriger les permissions finales
chown -R forge:forge node_modules/ 2>/dev/null || true
chmod -R 755 node_modules/ 2>/dev/null || true

# 11. Build des assets de production
log_info "ğŸ—ï¸ Build des assets de production..."
# Build Laravel assets
npx vite build || npm run build || npm run production
if [ $? -ne 0 ]; then
    log_warning "Build Laravel assets Ã©chouÃ©, mais continue..."
fi

# Build PWA Vue.js avec gÃ©nÃ©ration de fichiers statiques
log_info "ğŸ—ï¸ Build PWA Vue.js avec optimisations..."

# GÃ©nÃ©rer les fichiers statiques PWA optimisÃ©s
npm run pwa:build
if [ $? -eq 0 ]; then
    log_success "PWA buildÃ©e avec succÃ¨s"

    # VÃ©rifier que les fichiers ont Ã©tÃ© gÃ©nÃ©rÃ©s
    if [ -d "public/pwa/dist" ]; then
        log_info "ğŸ“ Fichiers PWA gÃ©nÃ©rÃ©s dans public/pwa/dist/"

        # CrÃ©er les dossiers de cache si nÃ©cessaires
        mkdir -p public/pwa/cache
        mkdir -p public/pwa/offline

        # Copier les assets critiques pour le cache
        if [ -d "public/pwa/dist/assets" ]; then
            cp -r public/pwa/dist/assets/* public/pwa/cache/ 2>/dev/null || true
        fi

        # CrÃ©er un fichier de version pour le cache busting
        echo "$(date +%s)" > public/pwa/version.txt

        log_success "Cache PWA configurÃ©"
    else
        log_warning "Dossier PWA dist non trouvÃ©"
    fi
else
    log_warning "Build PWA Ã©chouÃ©, mais continue..."
fi

log_success "Assets buildÃ©s"

# 12. RecrÃ©ation des dossiers nÃ©cessaires avec permissions
log_info "ğŸ“ CrÃ©ation des dossiers de storage..."
mkdir -p storage/logs
mkdir -p storage/framework/cache/data
mkdir -p storage/framework/sessions
mkdir -p storage/framework/views
mkdir -p storage/app/public
mkdir -p bootstrap/cache

# Configuration des permissions de base
chmod -R 775 storage bootstrap/cache 2>/dev/null || true
chown -R forge:www-data storage bootstrap/cache 2>/dev/null || true

log_success "Dossiers de storage crÃ©Ã©s avec permissions"

# 12.bis Publication des migrations Media Library (si nÃ©cessaires)
log_info "ğŸ“¦ Publication des migrations Spatie Media Library (si nÃ©cessaire)..."
if ls database/migrations/*create_media_table*.php >/dev/null 2>&1; then
    log_info "Migrations Media Library dÃ©jÃ  prÃ©sentes"
else
    $FORGE_PHP artisan vendor:publish --provider="Spatie\\MediaLibrary\\MediaLibraryServiceProvider" --tag="migrations" --force 2>/dev/null || log_warning "Publication des migrations MediaLibrary Ã©chouÃ©e"
fi

# 12.ter VÃ©rification de l'existence de la table media (Spatie) et correction si nÃ©cessaire
log_info "ğŸ§ª VÃ©rification de l'existence de la table media..."
MEDIA_CHECK=$($FORGE_PHP artisan tinker --execute="echo Schema::hasTable('media') ? 'MEDIA:1' : 'MEDIA:0';" 2>/dev/null | grep "MEDIA:")
if [[ $MEDIA_CHECK == *"MEDIA:0"* ]]; then
    log_warning "âš ï¸ Table media absente, tentative de migration ciblÃ©e..."
    # Republier au cas oÃ¹ et migrer spÃ©cifiquement le fichier create_media_table
    $FORGE_PHP artisan vendor:publish --provider="Spatie\\MediaLibrary\\MediaLibraryServiceProvider" --tag="migrations" --force 2>/dev/null || true
    MEDIA_FILE=$(ls database/migrations/*create_media_table*.php 2>/dev/null | head -n 1)
    # Fallback to our published filename if glob fails
    if [ -z "$MEDIA_FILE" ] && [ -f database/migrations/2025_08_13_215618_create_media_table.php ]; then
        MEDIA_FILE=database/migrations/2025_08_13_215618_create_media_table.php
    fi
    if [ -n "$MEDIA_FILE" ]; then
        if $FORGE_PHP artisan migrate --path="$MEDIA_FILE" --force; then
            log_success "âœ… Table media crÃ©Ã©e via migration: $MEDIA_FILE"
        else
            log_warning "âš ï¸ Ã‰chec de la migration ciblÃ©e media ($MEDIA_FILE)"
        fi
    else
        log_warning "âš ï¸ Aucune migration create_media_table trouvÃ©e"
    fi

    # Re-vÃ©rifier
    MEDIA_RECHECK=$($FORGE_PHP artisan tinker --execute="echo Schema::hasTable('media') ? 'MEDIA_FINAL:1' : 'MEDIA_FINAL:0';" 2>/dev/null | grep "MEDIA_FINAL:")
    if [[ $MEDIA_RECHECK == *"MEDIA_FINAL:1"* ]]; then
        log_success "âœ… Table media disponible aprÃ¨s correction"
    else
        log_error "âŒ Impossible de crÃ©er la table media automatiquement. VÃ©rifier manuellement."
    fi
else
    log_success "âœ… Table media dÃ©jÃ  prÃ©sente"
fi

# 13. Migration de la base de donnÃ©es avec correction des erreurs
log_info "ğŸ—„ï¸ Migration de la base de donnÃ©es avec corrections..."
if [ -f artisan ]; then
    # VÃ©rifier d'abord l'Ã©tat des colonnes push_notifications
    log_info "ğŸ” VÃ©rification des colonnes push_notifications..."

    PUSH_NOTIFICATIONS_CHECK=$($FORGE_PHP artisan tinker --execute="
    try {
        if (Schema::hasTable('push_notifications')) {
            \$columns = Schema::getColumnListing('push_notifications');
            \$hasContentType = in_array('content_type', \$columns);
            \$hasContentId = in_array('content_id', \$columns);
            echo 'PUSH_CHECK:' . (\$hasContentType ? '1' : '0') . ':' . (\$hasContentId ? '1' : '0');
        } else {
            echo 'PUSH_CHECK:NO_TABLE';
        }
    } catch (Exception \$e) {
        echo 'PUSH_CHECK:ERROR:' . \$e->getMessage();
    }
    " 2>/dev/null | grep "PUSH_CHECK")

    if [[ $PUSH_NOTIFICATIONS_CHECK == *"PUSH_CHECK:1:1"* ]]; then
        log_success "âœ… Colonnes content_type et content_id dÃ©jÃ  prÃ©sentes"
    elif [[ $PUSH_NOTIFICATIONS_CHECK == *"PUSH_CHECK:0:0"* ]] || [[ $PUSH_NOTIFICATIONS_CHECK == *"PUSH_CHECK:0:1"* ]] || [[ $PUSH_NOTIFICATIONS_CHECK == *"PUSH_CHECK:1:0"* ]]; then
        log_warning "âš ï¸ Colonnes push_notifications manquantes, correction nÃ©cessaire"

        # ExÃ©cuter la migration spÃ©cifique pour les colonnes content
        log_info "ğŸ”§ Application de la migration content_fields..."
        if $FORGE_PHP artisan migrate --path=database/migrations/2025_08_01_190812_add_content_fields_to_push_notifications_table.php --force; then
            log_success "âœ… Migration content_fields appliquÃ©e avec succÃ¨s"

            # VÃ©rification post-migration
            PUSH_POST_CHECK=$($FORGE_PHP artisan tinker --execute="
            try {
                \$columns = Schema::getColumnListing('push_notifications');
                \$hasContentType = in_array('content_type', \$columns);
                \$hasContentId = in_array('content_id', \$columns);
                echo 'POST_CHECK:' . (\$hasContentType ? '1' : '0') . ':' . (\$hasContentId ? '1' : '0');
            } catch (Exception \$e) {
                echo 'POST_CHECK:ERROR:' . \$e->getMessage();
            }
            " 2>/dev/null | grep "POST_CHECK")

            if [[ $PUSH_POST_CHECK == *"POST_CHECK:1:1"* ]]; then
                log_success "âœ… VÃ©rification post-migration rÃ©ussie - colonnes prÃ©sentes"

                # Test de crÃ©ation d'une notification pour valider
                log_info "ğŸ§ª Test de validation des nouvelles colonnes..."
                TEST_NOTIFICATION_RESULT=$($FORGE_PHP artisan tinker --execute="
                try {
                    \$testNotif = new App\\Models\\PushNotification();
                    \$testNotif->title = 'Test Migration';
                    \$testNotif->message = 'Test des colonnes content_type et content_id';
                    \$testNotif->content_type = 'recipe';
                    \$testNotif->content_id = 1;
                    \$testNotif->target_audience = 'all';
                    \$testNotif->status = 'draft';
                    \$testNotif->created_by = 1;
                    \$testNotif->save();
                    \$testNotif->delete();
                    echo 'TEST_NOTIF_SUCCESS';
                } catch (Exception \$e) {
                    echo 'TEST_NOTIF_ERROR:' . \$e->getMessage();
                }
                " 2>/dev/null | grep "TEST_NOTIF")

                if [[ $TEST_NOTIFICATION_RESULT == *"SUCCESS"* ]]; then
                    log_success "âœ… Test de validation rÃ©ussi - notifications push opÃ©rationnelles"
                else
                    log_error "âŒ Test de validation Ã©chouÃ©: $TEST_NOTIFICATION_RESULT"
                fi
            else
                log_error "âŒ VÃ©rification post-migration Ã©chouÃ©e: $PUSH_POST_CHECK"
            fi
        else
            log_error "âŒ Ã‰chec de la migration content_fields"
        fi
    else
        log_info "â„¹ï¸ Table push_notifications non trouvÃ©e ou autre problÃ¨me: $PUSH_NOTIFICATIONS_CHECK"
    fi

    # Tentative de migration normale pour toutes les autres migrations
    if $FORGE_PHP artisan migrate --force; then
        log_success "Migrations gÃ©nÃ©rales exÃ©cutÃ©es avec succÃ¨s"
    else
        log_warning "ProblÃ¨me avec les migrations gÃ©nÃ©rales, tentative de correction..."

        # Correction ciblÃ©e: migration ENUM/constraint push_notifications adaptÃ©e MySQL/Postgres
        if [ -f database/migrations/2025_08_01_185849_add_send_now_status_to_push_notifications_table.php ]; then
            log_info "ğŸ”§ Application de la migration push_notifications (compat MySQL/PGSQL)..."
            if $FORGE_PHP artisan migrate --path=database/migrations/2025_08_01_185849_add_send_now_status_to_push_notifications_table.php --force; then
                log_success "âœ… Migration push_notifications appliquÃ©e"
            else
                log_warning "âš ï¸ Ã‰chec migration ciblÃ©e push_notifications (peut Ãªtre dÃ©jÃ  appliquÃ©e)"
            fi
        fi

        # Diagnostic spÃ©cifique pour la colonne 'rank' en double
        log_info "ğŸ” Diagnostic des problÃ¨mes de migration..."

        # VÃ©rifier si l'erreur est liÃ©e Ã  la colonne 'rank'
        MIGRATION_ERROR=$($FORGE_PHP artisan migrate --force 2>&1 | grep -i "duplicate column name 'rank'" || echo "")

        if [[ ! -z "$MIGRATION_ERROR" ]]; then
            log_warning "ğŸ”§ Erreur de colonne 'rank' dÃ©tectÃ©e, correction en cours..."

            # Rollback de la derniÃ¨re migration problÃ©matique
            if $FORGE_PHP artisan migrate:rollback --step=1 --force 2>/dev/null; then
                log_info "Migration problÃ©matique annulÃ©e"
            fi

            # RÃ©essayer la migration
            if $FORGE_PHP artisan migrate --force; then
                log_success "âœ… Migrations appliquÃ©es aprÃ¨s correction"
            else
                log_error "âŒ Impossible d'appliquer les migrations mÃªme aprÃ¨s correction"
                # Continuer malgrÃ© l'erreur
            fi
        else
            log_warning "Autre problÃ¨me de migration dÃ©tectÃ©, continue..."
        fi
    fi

    # 13.bis. VÃ©rification / correction de la colonne dinor_ingredients
    log_info "ğŸ¥£ VÃ©rification de la colonne recipes.dinor_ingredients..."

    DINOR_ING_CHECK=$($FORGE_PHP artisan tinker --execute="
    try {
        if (Schema::hasTable('recipes')) {
            echo Schema::hasColumn('recipes', 'dinor_ingredients') ? 'DINOR_ING:1' : 'DINOR_ING:0';
        } else {
            echo 'DINOR_ING:NO_TABLE';
        }
    } catch (Exception \$e) {
        echo 'DINOR_ING:ERROR:' . \$e->getMessage();
    }
    " 2>/dev/null | grep "DINOR_ING")

    if [[ $DINOR_ING_CHECK == *"DINOR_ING:1"* ]]; then
        log_success "âœ… Colonne dinor_ingredients dÃ©jÃ  prÃ©sente"
    else
        log_warning "âš ï¸ Colonne dinor_ingredients absente, tentative de correction..."

        # Tenter d'abord la migration ciblÃ©e si elle existe
        DINOR_MIG_FILE=$(ls database/migrations/*add_dinor_ingredients_to_recipes_table*.php 2>/dev/null | head -n 1)
        if [ -n "$DINOR_MIG_FILE" ]; then
            log_info "ğŸ”§ Application de la migration: $DINOR_MIG_FILE"
            if $FORGE_PHP artisan migrate --path="$DINOR_MIG_FILE" --force; then
                log_success "âœ… Migration dinor_ingredients appliquÃ©e"
            else
                log_warning "âš ï¸ Ã‰chec de la migration ciblÃ©e, tentative ALTER TABLE..."
                DINOR_ALTER=$($FORGE_PHP artisan tinker --execute="
                try {
                    \Illuminate\Support\Facades\DB::statement(\"ALTER TABLE recipes ADD COLUMN dinor_ingredients JSON NULL AFTER ingredients\");
                    echo 'ALTER:JSON_OK';
                } catch (Exception \$e) {
                    try {
                        \Illuminate\Support\Facades\DB::statement(\"ALTER TABLE recipes ADD COLUMN dinor_ingredients LONGTEXT NULL AFTER ingredients\");
                        echo 'ALTER:LONGTEXT_OK';
                    } catch (Exception \$e2) {
                        echo 'ALTER:ERROR:' . \$e2->getMessage();
                    }
                }" 2>/dev/null | grep "ALTER:")
                log_info "RÃ©sultat: $DINOR_ALTER"
            fi
        else
            log_info "â„¹ï¸ Aucune migration ciblÃ©e trouvÃ©e, tentative ALTER TABLE directe..."
            DINOR_ALTER=$($FORGE_PHP artisan tinker --execute="
            try {
                \Illuminate\Support\Facades\DB::statement(\"ALTER TABLE recipes ADD COLUMN dinor_ingredients JSON NULL AFTER ingredients\");
                echo 'ALTER:JSON_OK';
            } catch (Exception \$e) {
                try {
                    \Illuminate\Support\Facades\DB::statement(\"ALTER TABLE recipes ADD COLUMN dinor_ingredients LONGTEXT NULL AFTER ingredients\");
                    echo 'ALTER:LONGTEXT_OK';
                } catch (Exception \$e2) {
                    echo 'ALTER:ERROR:' . \$e2->getMessage();
                }
            }" 2>/dev/null | grep "ALTER:")
            log_info "RÃ©sultat: $DINOR_ALTER"
        fi

        # Re-vÃ©rification finale
        DINOR_ING_RECHECK=$($FORGE_PHP artisan tinker --execute="
        try {
            echo Schema::hasColumn('recipes', 'dinor_ingredients') ? 'DINOR_ING_FINAL:1' : 'DINOR_ING_FINAL:0';
        } catch (Exception \$e) {
            echo 'DINOR_ING_FINAL:ERROR:' . \$e->getMessage();
        }
        " 2>/dev/null | grep "DINOR_ING_FINAL")

        if [[ $DINOR_ING_RECHECK == *"DINOR_ING_FINAL:1"* ]]; then
            log_success "âœ… Colonne dinor_ingredients disponible aprÃ¨s correction"
        else
            log_error "âŒ Impossible d'ajouter la colonne dinor_ingredients. VÃ©rifier manuellement."
        fi
    fi

    # Migration spÃ©cifique des catÃ©gories d'Ã©vÃ©nements (comme dans le script original)
    log_info "ğŸ—„ï¸ Migration spÃ©cifique des catÃ©gories d'Ã©vÃ©nements..."

    # Migration de la table event_categories
    $FORGE_PHP artisan migrate --path=database/migrations/2025_01_01_000000_create_event_categories_table.php --force 2>/dev/null || log_warning "Migration event_categories dÃ©jÃ  appliquÃ©e ou erreur"

    # Migration de l'ajout de event_category_id aux events
    $FORGE_PHP artisan migrate --path=database/migrations/2025_01_01_000001_add_event_category_id_to_events_table.php --force 2>/dev/null || log_warning "Migration event_category_id dÃ©jÃ  appliquÃ©e ou erreur"

    # Migration SplashScreen pour la customisation via Filament
    log_info "ğŸ¨ Migration de la table splash_screens..."

    # VÃ©rification robuste de l'existence de la table splash_screens et correction si nÃ©cessaire
    log_info "ğŸ§ª VÃ©rification de l'existence de la table splash_screens..."
    SPLASH_CHECK=$($FORGE_PHP artisan tinker --execute="try{echo Schema::hasTable('splash_screens') ? 'SPLASH:1' : 'SPLASH:0';}catch(Exception $e){echo 'SPLASH:ERROR';}" 2>/dev/null | grep "SPLASH:")
    if [[ $SPLASH_CHECK == *"SPLASH:0"* ]]; then
        log_warning "âš ï¸ Table splash_screens absente, tentative de migration ciblÃ©e..."
        if [ -f database/migrations/2025_08_13_205112_create_splash_screens_table.php ]; then
            # Appliquer une correction Ã  chaud pour les apostrophes ASCII qui cassent MySQL
            sed -i "s/Chargement de l\\'application/Chargement de l'application/g" database/migrations/2025_08_13_205112_create_splash_screens_table.php 2>/dev/null || true
            if $FORGE_PHP artisan migrate --path=database/migrations/2025_08_13_205112_create_splash_screens_table.php --force; then
                log_success "âœ… Table splash_screens crÃ©Ã©e via migration ciblÃ©e"
            else
                log_warning "âš ï¸ Ã‰chec de la migration ciblÃ©e splash_screens"
            fi
        else
            log_warning "âš ï¸ Aucune migration spÃ©cifique splash_screens incluse dans le dÃ©pÃ´t"
        fi

        # Re-vÃ©rification finale
        SPLASH_RECHECK=$($FORGE_PHP artisan tinker --execute="echo Schema::hasTable('splash_screens') ? 'SPLASH_FINAL:1' : 'SPLASH_FINAL:0';" 2>/dev/null | grep "SPLASH_FINAL:")
        if [[ $SPLASH_RECHECK == *"SPLASH_FINAL:1"* ]]; then
            log_success "âœ… Table splash_screens disponible aprÃ¨s correction"
        else
            log_error "âŒ Impossible de crÃ©er la table splash_screens automatiquement. VÃ©rifier manuellement."
        fi
    else
        log_success "âœ… Table splash_screens dÃ©jÃ  prÃ©sente"
    fi

else
    log_warning "Fichier artisan non trouvÃ©"
fi

# 14. Configuration de l'utilisateur admin (via seeder, mot de passe lu depuis .env)
log_info "ğŸ‘¤ Configuration de l'utilisateur admin..."

# Seul le seeder admin tourne Ã  chaque dÃ©ploiement (updateOrCreate, pas de donnÃ©es mÃ©tier)
if $FORGE_PHP artisan db:seed --class=ProductionAdminSeeder --force 2>/dev/null; then
    log_success "âœ… Admin configurÃ© avec le seeder spÃ©cialisÃ©"
else
    log_warning "Seeder spÃ©cialisÃ© non trouvÃ©, utilisation du seeder standard..."
    $FORGE_PHP artisan db:seed --class=AdminUserSeeder --force 2>/dev/null || log_warning "ProblÃ¨me avec AdminUserSeeder"
    log_success "âœ… Admin configurÃ© avec le seeder standard"
fi

# Les seeders de donnÃ©es (recettes, catÃ©gories, ingrÃ©dients, etc.) ne tournent
# que lors du PREMIER dÃ©ploiement. Ils restaurent du contenu supprimÃ© par l'admin
# et dupliquent les ingrÃ©dients si exÃ©cutÃ©s Ã  rÃ©pÃ©tition.
# Pour les relancer manuellement : php artisan db:seed --class=NomDuSeeder --force
log_info "ğŸ“‹ VÃ©rification des donnÃ©es de base..."

# Ne seeder que si les tables sont vides (premier dÃ©ploiement uniquement)
NEEDS_SEED=$($FORGE_PHP artisan tinker --execute="
\$cats = \App\Models\Category::count();
echo 'SEED_CHECK:' . (\$cats == 0 ? 'EMPTY' : 'HAS_DATA');
" 2>/dev/null | grep "SEED_CHECK")

if [[ $NEEDS_SEED == *"EMPTY"* ]]; then
    log_warning "Base de donnÃ©es vide â€” exÃ©cution des seeders de donnÃ©es initiales..."
    $FORGE_PHP artisan db:seed --class=CategorySeeder --force 2>/dev/null || true
    $FORGE_PHP artisan db:seed --class=EventCategoriesSeeder --force 2>/dev/null || true
    $FORGE_PHP artisan db:seed --class=IngredientsSeeder --force 2>/dev/null || true
    $FORGE_PHP artisan db:seed --class=PwaMenuItemSeeder --force 2>/dev/null || true
    $FORGE_PHP artisan db:seed --class=ProductionDataSeeder --force 2>/dev/null || true
    log_success "âœ… DonnÃ©es initiales crÃ©Ã©es"
else
    log_success "âœ… DonnÃ©es existantes prÃ©servÃ©es (seeders de contenu ignorÃ©s)"
fi

# VÃ©rification que l'admin est bien crÃ©Ã©
ADMIN_CHECK=$($FORGE_PHP artisan tinker --execute="
\$admin = App\\Models\\AdminUser::where('email', 'admin@dinor.app')->first();
if (\$admin && \$admin->is_active) {
    echo 'ADMIN_OK:' . \$admin->id . ':' . \$admin->name;
} else {
    echo 'ADMIN_PROBLEM';
}" 2>/dev/null | grep -E "ADMIN_OK|ADMIN_PROBLEM")

if [[ $ADMIN_CHECK == *"ADMIN_OK"* ]]; then
    ADMIN_ID=$(echo $ADMIN_CHECK | cut -d':' -f2)
    ADMIN_NAME=$(echo $ADMIN_CHECK | cut -d':' -f3)
    log_success "Admin vÃ©rifiÃ© et opÃ©rationnel (ID: $ADMIN_ID - $ADMIN_NAME)"
else
    log_warning "Tentative de crÃ©ation manuelle de l'admin..."

    # CrÃ©ation manuelle en cas d'Ã©chec des seeders (mot de passe lu depuis .env)
    $FORGE_PHP artisan tinker --execute="
    try {
        \$password = env('ADMIN_DEFAULT_PASSWORD');
        if (!\$password) {
            echo 'MANUAL_ADMIN_FAILED:ADMIN_DEFAULT_PASSWORD non defini dans .env';
        } else {
            \$admin = App\\Models\\AdminUser::updateOrCreate(
                ['email' => env('ADMIN_DEFAULT_EMAIL', 'admin@dinor.app')],
                [
                    'name' => env('ADMIN_DEFAULT_NAME', 'AdministrateurDinor'),
                    'password' => bcrypt(\$password),
                    'email_verified_at' => now(),
                    'is_active' => true
                ]
            );
            echo 'MANUAL_ADMIN_OK:' . \$admin->id;
        }
    } catch (Exception \$e) {
        echo 'MANUAL_ADMIN_FAILED:' . \$e->getMessage();
    }
    " 2>/dev/null || log_error "CrÃ©ation manuelle Ã©chouÃ©e"
fi

# 15. Correction des problÃ¨mes d'inscription aux tournois
log_info "ğŸ† Diagnostic et correction des tournois..."

# CrÃ©er un script temporaire pour la correction des tournois
cat > /tmp/fix_tournaments.php << 'EOF'
<?php
require_once '/home/forge/new.dinorapp.com/vendor/autoload.php';
$app = require_once '/home/forge/new.dinorapp.com/bootstrap/app.php';
$app->make(Illuminate\Contracts\Console\Kernel::class)->bootstrap();

use App\Models\Tournament;

$tournaments = Tournament::all();
$fixed = 0;

foreach ($tournaments as $tournament) {
    $needsFix = false;

    // VÃ©rifier si le tournoi a des problÃ¨mes d'inscription
    if ($tournament->status !== 'registration_open' && $tournament->status !== 'active') {
        $tournament->status = 'registration_open';
        $needsFix = true;
    }

    // Corriger les dates d'inscription si nÃ©cessaires
    $now = now();
    if (!$tournament->registration_start || $now < $tournament->registration_start) {
        $tournament->registration_start = $now->subDay();
        $needsFix = true;
    }

    if (!$tournament->registration_end || $now > $tournament->registration_end) {
        $tournament->registration_end = $now->addWeeks(2);
        $needsFix = true;
    }

    // S'assurer que le tournoi est public
    if (!$tournament->is_public) {
        $tournament->is_public = true;
        $needsFix = true;
    }

    if ($needsFix) {
        $tournament->save();
        $fixed++;
        echo "Tournoi corrigÃ©: {$tournament->name}\n";
    }
}

echo "TOURNAMENTS_FIXED:{$fixed}\n";
EOF

# ExÃ©cuter la correction des tournois
TOURNAMENT_FIX_RESULT=$($FORGE_PHP /tmp/fix_tournaments.php 2>/dev/null | grep "TOURNAMENTS_FIXED" || echo "TOURNAMENTS_FIXED:0")
TOURNAMENTS_FIXED=$(echo $TOURNAMENT_FIX_RESULT | cut -d':' -f2)

if [ "$TOURNAMENTS_FIXED" -gt 0 ]; then
    log_success "âœ… $TOURNAMENTS_FIXED tournoi(s) corrigÃ©(s) pour les inscriptions"
else
    log_info "â„¹ï¸ Aucun tournoi nÃ©cessitant de correction trouvÃ©"
fi

# Nettoyer le script temporaire
rm -f /tmp/fix_tournaments.php

# 16. Lien symbolique de stockage
log_info "ğŸ”— CrÃ©ation du lien symbolique de stockage..."
$FORGE_PHP artisan storage:link || log_warning "Lien symbolique dÃ©jÃ  existant"
log_success "Lien symbolique vÃ©rifiÃ©"

# 17. Optimisation Laravel pour la production
log_info "âš¡ Optimisation Laravel..."
$FORGE_PHP artisan config:cache
$FORGE_PHP artisan route:cache
$FORGE_PHP artisan view:cache
log_success "Optimisations appliquÃ©es"

# 17.5. VÃ©rification conditionnelle des caches Filament/Livewire
log_info "ğŸ” VÃ©rification des changements nÃ©cessitant un vidage de cache..."

# VÃ©rifier si des fichiers critiques ont changÃ© dans le dernier commit
CACHE_CRITICAL_CHANGES=$(git diff HEAD~1 --name-only 2>/dev/null | grep -E "(config/|routes/|app/Filament.*\.php|app/Livewire.*\.php|app/.*Resource.*\.php)" | wc -l)

if [ "$CACHE_CRITICAL_CHANGES" -gt 0 ]; then
    log_warning "ğŸ”„ Changements dÃ©tectÃ©s dans les composants Filament/Livewire ($CACHE_CRITICAL_CHANGES fichiers)"
    log_info "ğŸ“‚ Fichiers modifiÃ©s:"
    git diff HEAD~1 --name-only 2>/dev/null | grep -E "(config/|routes/|app/Filament.*\.php|app/Livewire.*\.php|app/.*Resource.*\.php)" | sed 's/^/   - /'

    log_info "ğŸ§¹ Vidage des caches Filament et redÃ©couverte des composants..."

    # Vider les caches Laravel spÃ©cifiques
    $FORGE_PHP artisan cache:clear || log_warning "ProblÃ¨me avec cache:clear"
    $FORGE_PHP artisan config:clear || log_warning "ProblÃ¨me avec config:clear"
    $FORGE_PHP artisan view:clear || log_warning "ProblÃ¨me avec view:clear"
    $FORGE_PHP artisan route:clear || log_warning "ProblÃ¨me avec route:clear"

    # RedÃ©couverte des composants Livewire
    if $FORGE_PHP artisan livewire:discover 2>/dev/null; then
        log_success "âœ… Composants Livewire redÃ©couverts"
    else
        log_warning "âš ï¸ Commande livewire:discover non disponible ou Ã©chouÃ©e"
    fi

    # Vider les caches PWA
    $FORGE_PHP artisan tinker --execute="
    try {
        \Illuminate\Support\Facades\Cache::tags(['pwa', 'recipes', 'events', 'tips', 'dinor-tv', 'pages'])->flush();
        echo 'PWA_CACHE_CLEARED';
    } catch (Exception \$e) {
        echo 'PWA_CACHE_ERROR:' . \$e->getMessage();
    }
    " 2>/dev/null | grep -q "PWA_CACHE_CLEARED" && log_success "âœ… Caches PWA vidÃ©s" || log_warning "âš ï¸ ProblÃ¨me avec les caches PWA"

    # Optimiser l'autoloader
    $FORGE_COMPOSER dump-autoload --optimize || log_warning "ProblÃ¨me avec dump-autoload"

    # Reconstruire les caches optimisÃ©s
    $FORGE_PHP artisan config:cache
    $FORGE_PHP artisan route:cache
    $FORGE_PHP artisan view:cache

    log_success "âœ… Caches Filament/Livewire mis Ã  jour"
else
    log_info "âœ… Aucun changement critique dÃ©tectÃ© - pas de vidage de cache nÃ©cessaire"
fi

# 18. Configuration des permissions (sÃ©curisÃ© pour Forge)
log_info "ğŸ”§ Configuration des permissions..."
chmod -R 755 storage bootstrap/cache 2>/dev/null || true
chown -R forge:forge storage bootstrap/cache 2>/dev/null || true
log_success "Permissions configurÃ©es"

# 19. VÃ©rification finale de l'Ã©tat de l'application
log_info "ğŸ” VÃ©rification finale..."

# Test rapide de la connexion Ã  la base de donnÃ©es
if $FORGE_PHP artisan migrate:status >/dev/null 2>&1; then
    log_success "Connexion base de donnÃ©es OK"
else
    log_warning "ProblÃ¨me potentiel avec la base de donnÃ©es"
fi

# Application des migrations de correction
log_info "ğŸ”§ Application des migrations de correction..."

# Migration spÃ©cifique pour corriger la contrainte MySQL users_role_check
log_info "ğŸ”§ Correction de la contrainte MySQL users_role_check..."
if [ -f database/migrations/2025_08_14_221203_fix_users_role_check_constraint_mysql_syntax.php ]; then
    if $FORGE_PHP artisan migrate --path=database/migrations/2025_08_14_221203_fix_users_role_check_constraint_mysql_syntax.php --force; then
        log_success "âœ… Contrainte users_role_check corrigÃ©e pour MySQL"
    else
        log_warning "âš ï¸ Ã‰chec de la correction de la contrainte users_role_check"
    fi
else
    log_warning "âš ï¸ Migration de correction de contrainte MySQL non trouvÃ©e"
fi

# Migration pour ajouter les colonnes manquantes Ã  dinor_tv (short_description, etc.)
log_info "ğŸ”§ VÃ©rification des colonnes DinorTV..."
if [ -f database/migrations/2025_08_13_210051_add_custom_images_support_to_dinor_tv_table.php ]; then
    if $FORGE_PHP artisan migrate --path=database/migrations/2025_08_13_210051_add_custom_images_support_to_dinor_tv_table.php --force; then
        log_success "âœ… Colonnes DinorTV (short_description, images) ajoutÃ©es"
    else
        log_warning "âš ï¸ Migration DinorTV dÃ©jÃ  appliquÃ©e ou Ã©chec"
    fi
else
    log_warning "âš ï¸ Migration DinorTV custom images non trouvÃ©e"
fi

# Application gÃ©nÃ©rale des migrations restantes
if $FORGE_PHP artisan migrate --force; then
    log_success "Migrations gÃ©nÃ©rales appliquÃ©es avec succÃ¨s"
else
    log_warning "ProblÃ¨me avec les migrations gÃ©nÃ©rales"
fi

# VÃ©rification finale de l'admin
FINAL_ADMIN_CHECK=$($FORGE_PHP artisan tinker --execute="
\$admin = App\\Models\\AdminUser::where('email', 'admin@dinor.app')->first();
echo \$admin ? 'FINAL_ADMIN_EXISTS' : 'FINAL_ADMIN_MISSING';
" 2>/dev/null | grep "FINAL_ADMIN")

if [[ $FINAL_ADMIN_CHECK == *"EXISTS"* ]]; then
    log_success "VÃ©rification finale admin: âœ… OK"
else
    log_warning "VÃ©rification finale admin: âš ï¸ ProblÃ¨me potentiel"
fi

# VÃ©rification finale des notifications push
log_info "ğŸ”” VÃ©rification finale des notifications push..."
FINAL_PUSH_CHECK=$($FORGE_PHP artisan tinker --execute="
try {
    if (Schema::hasTable('push_notifications')) {
        \$columns = Schema::getColumnListing('push_notifications');
        \$hasContentType = in_array('content_type', \$columns);
        \$hasContentId = in_array('content_id', \$columns);
        if (\$hasContentType && \$hasContentId) {
            echo 'PUSH_FINAL_OK';
        } else {
            echo 'PUSH_FINAL_MISSING_COLS';
        }
    } else {
        echo 'PUSH_FINAL_NO_TABLE';
    }
} catch (Exception \$e) {
    echo 'PUSH_FINAL_ERROR:' . \$e->getMessage();
}
" 2>/dev/null | grep "PUSH_FINAL")

if [[ $FINAL_PUSH_CHECK == *"OK"* ]]; then
    log_success "âœ… Notifications push opÃ©rationnelles - colonnes content_type et content_id prÃ©sentes"
else
    log_warning "âš ï¸ ProblÃ¨me potentiel avec les notifications push: $FINAL_PUSH_CHECK"
fi

# Test de l'API des tournois
log_info "ğŸ§ª Test de l'API des tournois..."
TOURNAMENT_API_TEST=$($FORGE_PHP artisan tinker --execute="
try {
    \$tournaments = App\\Models\\Tournament::where('is_public', true)->count();
    echo 'TOURNAMENT_API_OK:' . \$tournaments;
} catch (Exception \$e) {
    echo 'TOURNAMENT_API_ERROR:' . \$e->getMessage();
}
" 2>/dev/null | grep "TOURNAMENT_API")

if [[ $TOURNAMENT_API_TEST == *"OK"* ]]; then
    TOURNAMENT_COUNT=$(echo $TOURNAMENT_API_TEST | cut -d':' -f2)
    log_success "API tournois OK - $TOURNAMENT_COUNT tournoi(s) public(s)"
else
    log_warning "ProblÃ¨me potentiel avec l'API des tournois"
fi

# 20. Rechargement PHP-FPM (comme dans le script original)
log_info "ğŸ”„ Rechargement PHP-FPM..."
touch /tmp/fpmlock 2>/dev/null || true
( flock -w 10 9 || exit 1
    echo 'Rechargement PHP FPM...'; sudo -S service $FORGE_PHP_FPM reload ) 9</tmp/fpmlock 2>/dev/null || log_warning "Rechargement PHP-FPM Ã©chouÃ©"

# 21. Sortie du mode maintenance
log_info "ğŸŸ¢ Sortie du mode maintenance..."
$FORGE_PHP artisan up
log_success "Application remise en ligne"

echo ""
echo "ğŸ‰ === DÃ‰PLOIEMENT DIGITAL OCEAN TERMINÃ‰ AVEC SUCCÃˆS ==="
echo ""
echo "ğŸ“‹ Informations de connexion admin:"
echo "   ğŸŒ Dashboard: https://new.dinorapp.com/admin/login"
echo "   ğŸ“§ Email: admin@dinor.app"
echo "   ğŸ”‘ Mot de passe: [configurÃ© dans .env sur le serveur]"
echo ""
echo "ğŸ“‹ VÃ©rifications recommandÃ©es:"
echo "   - API Test: https://new.dinorapp.com/api/test/database-check"
echo "   - API Tournois: https://new.dinorapp.com/api/v1/tournaments"
echo "   - API Pages: https://new.dinorapp.com/api/pages"
echo "   - Notifications Push: https://new.dinorapp.com/admin/push-notifications/create"
echo "   - Logs: storage/logs/laravel.log"
echo ""
echo "ğŸ”§ Corrections appliquÃ©es:"
echo "   âœ… Migration de la colonne 'rank' corrigÃ©e"
echo "   âœ… Tournois configurÃ©s pour les inscriptions"
echo "   âœ… Pages iframe opÃ©rationnelles"
echo "   âœ… Notifications push avec colonnes content_type/content_id"
echo "   âœ… Colonne recipes.dinor_ingredients ajoutÃ©e si manquante"
echo "   âœ… ENUM difficulty des recettes Ã©tendu (beginner, easy, medium, hard, expert)"
echo "   âœ… Champ category_id des Ã©vÃ©nements rendu nullable"
echo "   âœ… Configuration des logs Laravel corrigÃ©e"
echo "   âœ… Composant KeyValue Filament corrigÃ© (suppression de collapsible)"
echo ""
echo "âœ… DÃ©ploiement terminÃ©!"
